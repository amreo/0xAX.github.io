<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haskel on Just a memo</title>
    <link>https://0xAX.github.io/categories/haskel/</link>
    <description>Recent content in Haskel on Just a memo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 11 May 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://0xAX.github.io/categories/haskel/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My thoughts about why Haskell is not popular</title>
      <link>https://0xax.github.io/haskell_not_popular/</link>
      <pubDate>Sun, 11 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0xax.github.io/haskell_not_popular/</guid>
      <description>

&lt;p&gt;Despite Haskell programming language is not young language, it has a really great and helpful community, it has big amount of libraries, unfortunately Haskell is not popular programming language. I&amp;rsquo;m not against this programming language, opposite, haskell&amp;rsquo;s unpopularity makes me sad. I will not write about haskell popularity in industry, I&amp;rsquo;ll try to explain my thoughts about &amp;ldquo;Why Haskell is not popular&amp;rdquo; not as Haskell expert, not as professional Haskell developer (i don&amp;rsquo;t get payment for Haskell programming), but from position of usual developer who started to learn/experiment with Haskell some months ago and already don&amp;rsquo;t afraid monads :). I can&amp;rsquo;t So I will try to explain my opinion about Why Haskell is not popular in this post.&lt;/p&gt;

&lt;h2 id=&#34;myths&#34;&gt;Myths&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m not long time with Haskell and I don&amp;rsquo;t know all myths/stories/jokes and other funny things about Haskell, I know one popular myth (for my look it&amp;rsquo;s a myth) that Haskell is a difficult. Difficult to learn, difficult to use, not important, it is difficult. I think it&amp;rsquo;s old myth, I remember it before I started to learn Haskell. I think that it is really myth and Haskell can be not so hard as you can think about it. It is not difficult, it is different. If you&amp;rsquo;re using python,ruby,C++,javascript,java,something else&amp;hellip; Haskell will be really different. Why it is different? There are many reasons for this like: another programming paradigm, lazy evaluations, different concepts and etc&amp;hellip; But of course it is not a big problem and relatively easy to solve. Developer just need to spend more time to learn it than with another programming languages like python,javascript and etc&amp;hellip; (Except C++ of course :))&lt;/p&gt;

&lt;h2 id=&#34;lack-of-documentation&#34;&gt;Lack of documentation&lt;/h2&gt;

&lt;p&gt;The Lack of documentation is a first problem in this list that related with practical side of Haskell usage. I don&amp;rsquo;t mean that Haskell as language has bad documentation, it is not true. I&amp;rsquo;m speaking about Haskell libraries documentation. It&amp;rsquo;s the one of big problem that stands on the road to Haskell popularity. Sooner or later after start of Haskell learning developer will want to use libraries written in Haskell. We can easily find library by name, or functions/data types name with Hoogle, it is good, but how to use this libraries if developer doesn&amp;rsquo;t program in Haskell a couple years and library has no or has but bad documentation. For example some time ago I played with WAI and i was need in websockets. Fortunately WAI has &lt;a href=&#34;http://hackage.haskell.org/package/wai-websockets-3.0.0&#34;&gt;wai-websockets&lt;/a&gt; package but let&amp;rsquo;s look on it&amp;rsquo;s &lt;a href=&#34;http://hackage.haskell.org/package/wai-websockets-3.0.0/docs/Network-Wai-Handler-WebSockets.html&#34;&gt;documentation&lt;/a&gt;. How to use it? I don&amp;rsquo;t know how about you, but I don&amp;rsquo;t understand. I see only one way out of this: to read &lt;a href=&#34;https://github.com/yesodweb/wai/blob/master/wai-websockets/server.lhs&#34;&gt;wai-websockets&lt;/a&gt; source code or examples. Is it good? I&amp;rsquo;m not sure.&lt;/p&gt;

&lt;h2 id=&#34;standard-library&#34;&gt;Standard Library&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s talk about Haskell&amp;rsquo;s standard library. On my look it has many really useful things for haskell and has really little amount things for Real World play. What it means when I am telling about Real World. It&amp;rsquo;s simple, i mean that Haskell standard library has many things like Control.Category, Control.Arrow, Data.Typeable and etc&amp;hellip; Again, I don&amp;rsquo;t know how is it for you, but for me and I think other newbie Haskell developers: Category, Arrow and other magic words are just words without any meaning. Not, i know Arrows, Monads are very useful in Haskell, but where is the something like Network.TcpClient, Network.HttpServer and etc&amp;hellip; I know that Haskell has separate libraries for TCP, HTTP and other network and not only network things. But imagine, for exmaple I just started with Haskell and I want to write simple example like sending HTTP request and getting response, i need to understand where to find library for this, how to install it and etc&amp;hellip; I don&amp;rsquo;t speak that Haskell standard library must have all things for all case, but things like http client in stdlib is a standard case. Or i&amp;rsquo;m wrong? Let&amp;rsquo;s look on golang for example. I think that it has a perfect standard library. Look on it and haskell standard library, do you feel difference? Golang is only five years and Haskell is 24, so big difference. Of course I have no statistic, but I see that golang is much popular for this moment. I don&amp;rsquo;t think that it is main reason but one of.&lt;/p&gt;

&lt;h2 id=&#34;why-to-learn&#34;&gt;Why to learn&lt;/h2&gt;

&lt;p&gt;I think it&amp;rsquo;s not only Haskell problem, but other languages too. I see only one answer for this question: To get/improve knowledges in functional programming and look on your working programming language with other eyes after it. Yes, getting new knowledges it is very good. But what about practical side? I know that somewhere developers who get money for Haskell programming, but I don&amp;rsquo;t see tons of vacancies for Haskell developers like for javascript, ruby or other tools and it is problem. Let&amp;rsquo;s look in another side. For example i want to start learn Haskell for my super-cool pet project. But why Haskell in this case? For web development I can take habitual ruby/python/php, for system programming I can take C/C++ or maybe Rust, for concurrent programming I will choose erlang. So why i need to learn new programming language and in addition so different from my standard tools?&lt;/p&gt;

&lt;h2 id=&#34;lazyness&#34;&gt;Lazyness&lt;/h2&gt;

&lt;p&gt;When we start to learn Haskell we can read something like this: Haskell - general purpose programming language with non-strict evaluation. I think that many developers know about lazy evaluations, but I am really not sure that all of they knows how it works, how to correctly use it and etc&amp;hellip; In this way, I as beginner in Haskell must learn not only another programming paradigm, but also another evaluation order. It is much harder, because it is much implicit. For example let&amp;rsquo;s take a look at popular ByteString library. It provides two implementations lazy strings and strict. But I still don&amp;rsquo;t know where to use first and where to use second.&lt;/p&gt;

&lt;h2 id=&#34;different-abstractions&#34;&gt;Different abstractions&lt;/h2&gt;

&lt;p&gt;It is problem of Haskell learning. Haskell uses different abstractions than other programming languages. And if you know python for example it will be much easy to learn ruby than Haskell. Let&amp;rsquo;s look on simple echo example. You need to read input from stdin and prtin this string again. How we do it with python language:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;import sys
data = sys.stdin.readlines()
print data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All is transparent enough. We do this task with all imperative programming languages in this way. First we reading from stdin and put result to a variable and than pass this variable to the printing function. Let&amp;rsquo;s look at the same Haskell example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main = do
  getLine &amp;gt;&amp;gt;= putStrLn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok. Developer can guess about getLine and putStrLn, but what is it &amp;gt;&amp;gt;=. If we open documentation we will read something like this: &amp;gt;&amp;gt;= combine two monadic values&amp;hellip; &amp;ldquo;combine two monadic values&amp;hellip;&amp;rdquo;. What is it Monad, How to use Monad and many many different questions with not easy answers sometimes. And it is only monads (concept which standard developer could not hear never), but there are many different concepts like Functors, Comonads and many many others which you can&amp;rsquo;t meet in standard programming languages.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So it was a short list of my thoughts why Haskell is not popular. I am very interesting what do you think about Haskell popularity.
In the end I want to remind that all from this post only my opinion and if you&amp;rsquo;re agree or disagree with me write me a comment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get function execution time in Haskell</title>
      <link>https://0xax.github.io/haskel-execution-time/</link>
      <pubDate>Mon, 13 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0xax.github.io/haskel-execution-time/</guid>
      <description>

&lt;p&gt;Some times ago I encountered with question: How to get function execution time in Haskell program? I asked this question at &lt;a href=&#34;http://stackoverflow.com/questions/6766450/haskell-function-execution-time&#34;&gt;StackOverflow&lt;/a&gt;, and got some useful answers. Here i will try to describe how to do it. For example we have simple haskell program which will calculate sum of prime numbers which are between 0 and 10000. Something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module TimingTest where

main :: IO()
main = do
	putStrLn &amp;quot;Start&amp;quot;
	putStrLn (&amp;quot;Result: &amp;quot; ++ show primesSum)
	putStrLn &amp;quot;Done&amp;quot;


--
-- Returns True if `n` is prime
--
isPrime :: Int -&amp;gt; Bool
isPrime n = null [ x | x &amp;lt;- [2..n - 1], n `mod` x  == 0]

primesSum :: Int
primesSum = sum [x | x &amp;lt;- [2..10000], isPrime x == True]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, it&amp;rsquo;s not the best implementation of prime numbers, but it&amp;rsquo;s not important at the current moment. Let&amp;rsquo;s see what we have for checking execution time.&lt;/p&gt;

&lt;h2 id=&#34;time&#34;&gt;Time&lt;/h2&gt;

&lt;p&gt;First of all, the simplest method to get execution time is time command. Compile our source code and execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time ./TimingTest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We must get something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;real 0m3.503s
user 0m3.492s
sys 0m0.004s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ghci&#34;&gt;GHCI&lt;/h2&gt;

&lt;p&gt;The second method is just add &lt;code&gt;:set +s&lt;/code&gt; in &lt;code&gt;ghci&lt;/code&gt; before the function execution. Of course it&amp;rsquo;s not the best method, because functions run much slower in `&lt;code&gt;ghci&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;timeit&#34;&gt;TimeIt&lt;/h2&gt;

&lt;p&gt;The third method is to use &lt;a href=&#34;http://hackage.haskell.org/package/timeit&#34;&gt;TimeIt&lt;/a&gt; haskell library by Lennart Augustsson. Very little, but useful library with simple API. It consist only from two functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;timeIt :: IO a -&amp;gt; IO a -- | Wrap an IO computation so that it prints out the execution time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;timeItT :: IO a -&amp;gt; IO (Double, a)Source -- | Wrap an IO computation so that it returns execution time is seconds as well as the real value.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s remake our main function as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import System.TimeIt

main :: IO()
main = do
 	putStrLn &amp;quot;Start&amp;quot;
	timeIt $ putStrLn (&amp;quot;Result: &amp;quot; ++ show primesSum)
	putStrLn &amp;quot;End&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and will get something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Start
Result: 5736396
CPU time: 8.22s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;criterion&#34;&gt;Criterion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://hackage.haskell.org/package/criterion&#34;&gt;Criterion&lt;/a&gt; library provides a powerful but simple way to measure software performance by Bryan O&amp;rsquo;Sullivan. For using it, will remake again our main function as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module Main where

import Criterion.Main

main :: IO()
main = defaultMain [
       bgroup &amp;quot;Prime numbers.&amp;quot; [bench &amp;quot;prime numbers benchmark&amp;quot; $ whnfIO (putStrLn $ show primesSum)]
       ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and as a result we will get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;estimating clock resolution...
mean is 3.760062 us (160001 iterations)
found 3006 outliers among 159999 samples (1.9%)
2461 (1.5%) high severe

estimating cost of a clock call...
mean is 98.08812 ns (28 iterations)
found 4 outliers among 28 samples (14.3%)
4 (14.3%) low severe
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>